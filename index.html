<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PSP Fighter - Pixel Arena</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #050608;
      overflow: hidden;
      font-family: monospace;
      user-select: none;
    }

    canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    .hud {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      padding: 10px;
      box-sizing: border-box;
      color: white;
      text-shadow: 2px 2px 0px rgba(0,0,0,0.8);
      pointer-events: none;
    }

    .barWrap {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .hpBox {
      width: 40%;
      height: 16px;
      border: 2px solid rgba(255,255,255,0.9);
      background: rgba(0,0,0,0.6);
      border-radius: 4px;
      overflow: hidden;
      box-shadow: 0 0 12px rgba(255,255,255,0.12);
    }

    .hpFill {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #00ff77, #ffee00, #ff3300);
      transition: width 0.08s linear;
    }

    .nameRow {
      display: flex;
      justify-content: space-between;
      margin-top: 6px;
      font-size: 12px;
      opacity: 0.95;
    }

    .centerText {
      position: absolute;
      width: 100%;
      text-align: center;
      top: 40%;
      font-size: 42px;
      color: white;
      letter-spacing: 3px;
      text-shadow: 4px 4px 0px rgba(0,0,0,0.9);
      pointer-events: none;
      opacity: 0;
      transform: scale(1.1);
      transition: opacity 0.2s ease;
    }

    .hint {
      position: absolute;
      bottom: 8px;
      left: 8px;
      font-size: 12px;
      color: rgba(255,255,255,0.8);
      background: rgba(0,0,0,0.35);
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.12);
    }

    .winCount {
      position: absolute;
      bottom: 8px;
      right: 8px;
      font-size: 12px;
      color: rgba(255,255,255,0.8);
      background: rgba(0,0,0,0.35);
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.12);
    }
  </style>
</head>
<body>
  <div class="hud">
    <div class="barWrap">
      <div class="hpBox"><div id="hpP" class="hpFill"></div></div>
      <div style="font-size:14px; opacity:0.9;">ROUND 1</div>
      <div class="hpBox"><div id="hpE" class="hpFill"></div></div>
    </div>
    <div class="nameRow">
      <div><b>PLAYER</b> - Sen</div>
      <div><b>CPU</b> - Rakip</div>
    </div>
  </div>

  <div id="centerText" class="centerText">FIGHT!</div>

  <div class="hint">
    Kontroller: <b>A/D</b> yürü • <b>W</b> zıpla • <b>S</b> eğil • <b>J</b> yumruk • <b>K</b> tekme • <b>L</b> dash
  </div>

  <div id="wins" class="winCount">Wins: 0</div>

  <canvas id="game"></canvas>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const hpP = document.getElementById("hpP");
  const hpE = document.getElementById("hpE");
  const centerText = document.getElementById("centerText");
  const winsUI = document.getElementById("wins");

  // PSP vibe
  const BASE_SCALE = 3; // pixel upscale
  const LOGICAL_W = 320;
  const LOGICAL_H = 180;

  canvas.width = LOGICAL_W;
  canvas.height = LOGICAL_H;

  function fitCanvas() {
    const scale = Math.floor(Math.min(window.innerWidth / LOGICAL_W, window.innerHeight / LOGICAL_H));
    canvas.style.width = (LOGICAL_W * scale) + "px";
    canvas.style.height = (LOGICAL_H * scale) + "px";
  }
  window.addEventListener("resize", fitCanvas);
  fitCanvas();

  // Persistent wins
  let wins = parseInt(localStorage.getItem("pspFighterWins") || "0", 10);
  winsUI.textContent = "Wins: " + wins;

  // Load player image (your photo)
  const playerImg = new Image();
  playerImg.src = "player.png";

  // We'll generate a pixel sprite from your photo
  // and then animate it procedurally (limbs movement)
  function makePixelSprite(img, w=32, h=48) {
    const off = document.createElement("canvas");
    off.width = w;
    off.height = h;
    const octx = off.getContext("2d");

    // crop center-ish
    const sx = Math.max(0, (img.width - img.height) / 2);
    const sy = 0;
    const sw = Math.min(img.width, img.height);
    const sh = sw;

    octx.imageSmoothingEnabled = true;
    octx.drawImage(img, sx, sy, sw, sh, 0, 0, w, h);

    // Pixelate: draw into smaller buffer then scale up
    const px = document.createElement("canvas");
    px.width = 16;
    px.height = 24;
    const pctx = px.getContext("2d");
    pctx.imageSmoothingEnabled = true;
    pctx.drawImage(off, 0, 0, px.width, px.height);

    // Posterize (reduce colors)
    const imgData = pctx.getImageData(0, 0, px.width, px.height);
    const d = imgData.data;

    function posterize(v) {
      // PSP-ish palette compression
      const levels = 5;
      return Math.round((v / 255) * levels) * (255 / levels);
    }

    for (let i=0; i<d.length; i+=4) {
      d[i] = posterize(d[i]);       // r
      d[i+1] = posterize(d[i+1]);   // g
      d[i+2] = posterize(d[i+2]);   // b
      // alpha stays
    }
    pctx.putImageData(imgData, 0, 0);

    // Now scale to final sprite
    const final = document.createElement("canvas");
    final.width = w;
    final.height = h;
    const fctx = final.getContext("2d");
    fctx.imageSmoothingEnabled = false;
    fctx.drawImage(px, 0, 0, px.width, px.height, 0, 0, w, h);

    return final;
  }

  // Arena + camera
  const world = {
    w: 1200,
    floorY: 145,
  };

  const keys = {};
  window.addEventListener("keydown", (e) => keys[e.key.toLowerCase()] = true);
  window.addEventListener("keyup", (e) => keys[e.key.toLowerCase()] = false);

  // Combat system
  function rectsOverlap(a, b) {
    return (
      a.x < b.x + b.w &&
      a.x + a.w > b.x &&
      a.y < b.y + b.h &&
      a.y + a.h > b.y
    );
  }

  function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
  }

  function lerp(a, b, t) {
    return a + (b-a) * t;
  }

  // Screen shake
  let shake = 0;
  function doShake(amount) {
    shake = Math.max(shake, amount);
  }

  // Hit sparks particles
  const particles = [];
  function spawnHitSparks(x, y, dir) {
    for (let i=0; i<12; i++) {
      particles.push({
        x, y,
        vx: (Math.random()*1.8 + 0.4) * dir,
        vy: (Math.random()*-1.8 - 0.5),
        life: 18 + Math.random()*12,
      });
    }
  }

  // Fighters
  function createFighter(name, x, face=1, isCPU=false) {
    return {
      name,
      x,
      y: world.floorY - 42,
      vx: 0,
      vy: 0,
      w: 18,
      h: 42,
      face, // 1 right, -1 left
      hp: 100,
      stamina: 100,
      grounded: true,
      crouch: false,
      attacking: false,
      attackTimer: 0,
      attackType: null,
      hitCooldown: 0,
      dashCooldown: 0,
      stunned: 0,
      isCPU,
      state: "idle",
      animT: 0,
      combo: 0,
      comboTimer: 0,
      special: 0, // ultimate bar
    };
  }

  const player = createFighter("PLAYER", 220, 1, false);
  const enemy = createFighter("CPU", 520, -1, true);

  // Sprite generation placeholders
  let playerSprite = null;

  // CPU sprite is just a custom pixel guy
  function drawEnemySprite(x, y, scale, anim, facing) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(facing, 1);

    // body
    ctx.fillStyle = "#222";
    ctx.fillRect(-6, -30, 12, 18);

    // head
    ctx.fillStyle = "#d7b48a";
    ctx.fillRect(-5, -42, 10, 10);

    // eyes
    ctx.fillStyle = "#000";
    ctx.fillRect(-3, -38, 2, 2);
    ctx.fillRect(1, -38, 2, 2);

    // arms (animated)
    const armSwing = Math.sin(anim * 10) * 2;
    ctx.fillStyle = "#444";
    ctx.fillRect(-10, -28 + armSwing, 4, 12);
    ctx.fillRect(6, -28 - armSwing, 4, 12);

    // legs (animated)
    const legSwing = Math.sin(anim * 10 + 1.2) * 2;
    ctx.fillStyle = "#111";
    ctx.fillRect(-6, -12 + legSwing, 5, 12);
    ctx.fillRect(1, -12 - legSwing, 5, 12);

    ctx.restore();
  }

  // Player sprite draw with procedural limb movement
  function drawPlayerSprite(spriteCanvas, x, y, anim, facing, state) {
    if (!spriteCanvas) return;

    ctx.save();
    ctx.translate(x, y);
    ctx.scale(facing, 1);

    // shadow
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#000";
    ctx.fillRect(-10, 2, 20, 4);
    ctx.globalAlpha = 1;

    // Limb animation offsets
    const walkSwing = Math.sin(anim * 10) * 2;
    const walkSwing2 = Math.sin(anim * 10 + 1.8) * 2;

    // base sprite position
    let bodyY = -42;
    if (state === "jump") bodyY -= 2;
    if (state === "crouch") bodyY += 10;
    if (state === "hit") bodyY += 1;

    // legs (fake pixel legs)
    ctx.fillStyle = "#111";
    ctx.fillRect(-6, -12 + walkSwing, 5, 12);
    ctx.fillRect(1, -12 - walkSwing, 5, 12);

    // arms
    ctx.fillStyle = "#222";
    if (state === "punch") {
      ctx.fillRect(6, -30, 10, 4);
      ctx.fillRect(-10, -28, 4, 12);
    } else if (state === "kick") {
      ctx.fillRect(6, -28, 4, 12);
      ctx.fillRect(-10, -28 + walkSwing2, 4, 12);
    } else {
      ctx.fillRect(6, -28 - walkSwing2, 4, 12);
      ctx.fillRect(-10, -28 + walkSwing2, 4, 12);
    }

    // draw pixelated body from your photo
    ctx.drawImage(spriteCanvas, -16, bodyY, 32, 48);

    // dash glow
    if (state === "dash") {
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "#00ccff";
      ctx.fillRect(-18, -46, 36, 52);
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  // Attack hitboxes
  function getAttackBox(f) {
    if (!f.attacking) return null;

    if (f.attackType === "punch") {
      return {
        x: f.x + (f.face === 1 ? 12 : -18),
        y: f.y + 10,
        w: 16,
        h: 12
      };
    }

    if (f.attackType === "kick") {
      return {
        x: f.x + (f.face === 1 ? 10 : -20),
        y: f.y + 18,
        w: 20,
        h: 10
      };
    }

    return null;
  }

  function getHurtBox(f) {
    return { x: f.x - f.w/2, y: f.y, w: f.w, h: f.h };
  }

  function showCenterText(txt, time=700) {
    centerText.textContent = txt;
    centerText.style.opacity = "1";
    setTimeout(() => {
      centerText.style.opacity = "0";
    }, time);
  }

  function applyDamage(attacker, target, dmg, knock) {
    if (target.hitCooldown > 0) return;

    target.hp -= dmg;
    target.hp = Math.max(0, target.hp);

    target.vx += knock * attacker.face;
    target.stunned = 12;
    target.hitCooldown = 16;

    attacker.special = clamp(attacker.special + 8, 0, 100);

    doShake(3);
    spawnHitSparks(target.x, target.y + 18, attacker.face);

    // combo system
    attacker.combo++;
    attacker.comboTimer = 50;
  }

  // CPU AI
  function cpuThink(cpu, target) {
    if (cpu.stunned > 0) return;

    const dist = target.x - cpu.x;
    cpu.face = dist > 0 ? 1 : -1;

    const absDist = Math.abs(dist);

    // approach
    if (absDist > 60) {
      cpu.vx += cpu.face * 0.18;
      cpu.state = "walk";
    } else {
      // attack randomly
      if (!cpu.attacking && cpu.attackTimer <= 0) {
        const r = Math.random();
        if (r < 0.65) {
          cpu.attacking = true;
          cpu.attackType = "punch";
          cpu.attackTimer = 16;
          cpu.state = "punch";
        } else {
          cpu.attacking = true;
          cpu.attackType = "kick";
          cpu.attackTimer = 22;
          cpu.state = "kick";
        }
      } else {
        cpu.state = "idle";
      }

      // small backstep sometimes
      if (Math.random() < 0.02) {
        cpu.vx -= cpu.face * 1.4;
      }
    }

    // occasional jump
    if (cpu.grounded && Math.random() < 0.006) {
      cpu.vy = -4.2;
      cpu.grounded = false;
      cpu.state = "jump";
    }

    // dash escape if low HP
    if (cpu.hp < 35 && cpu.dashCooldown <= 0 && Math.random() < 0.02) {
      cpu.vx -= cpu.face * 4.8;
      cpu.dashCooldown = 70;
      cpu.state = "dash";
    }
  }

  // Game loop
  let camX = 0;
  let gameOver = false;
  let fightStarted = false;
  let introTimer = 70;

  showCenterText("ROUND 1", 900);
  setTimeout(() => showCenterText("FIGHT!", 800), 900);

  function updateFighter(f) {
    f.animT += 0.016;

    if (f.comboTimer > 0) f.comboTimer--;
    else f.combo = 0;

    if (f.hitCooldown > 0) f.hitCooldown--;
    if (f.dashCooldown > 0) f.dashCooldown--;
    if (f.stunned > 0) f.stunned--;

    // gravity
    f.vy += 0.18;

    // friction
    f.vx *= 0.86;

    // clamp speed
    f.vx = clamp(f.vx, -4.5, 4.5);

    // move
    f.x += f.vx;
    f.y += f.vy;

    // floor collision
    if (f.y >= world.floorY - f.h) {
      f.y = world.floorY - f.h;
      f.vy = 0;
      f.grounded = true;
    } else {
      f.grounded = false;
    }

    // arena bounds
    f.x = clamp(f.x, 30, world.w - 30);

    // handle attacks
    if (f.attackTimer > 0) {
      f.attackTimer--;
      if (f.attackTimer === 0) {
        f.attacking = false;
        f.attackType = null;
        if (f.state === "punch" || f.state === "kick") f.state = "idle";
      }
    }
  }

  function handleInput() {
    if (!fightStarted) return;
    if (player.stunned > 0) return;

    const left = keys["a"];
    const right = keys["d"];
    const jump = keys["w"];
    const crouch = keys["s"];
    const punch = keys["j"];
    const kick = keys["k"];
    const dash = keys["l"];

    player.crouch = crouch;

    if (left) {
      player.vx -= 0.35;
      player.face = -1;
      if (player.grounded) player.state = "walk";
    }
    if (right) {
      player.vx += 0.35;
      player.face = 1;
      if (player.grounded) player.state = "walk";
    }

    if (!left && !right && player.grounded && !player.attacking && !player.crouch) {
      if (player.state !== "punch" && player.state !== "kick") {
        player.state = "idle";
      }
    }

    if (player.crouch && player.grounded) {
      player.state = "crouch";
    }

    if (jump && player.grounded && !player.crouch) {
      player.vy = -4.8;
      player.grounded = false;
      player.state = "jump";
    }

    if (dash && player.dashCooldown <= 0) {
      player.vx += player.face * 5.2;
      player.dashCooldown = 60;
      player.state = "dash";
      doShake(1.5);
    }

    if (punch && !player.attacking && player.attackTimer <= 0 && !player.crouch) {
      player.attacking = true;
      player.attackType = "punch";
      player.attackTimer = 14;
      player.state = "punch";
    }

    if (kick && !player.attacking && player.attackTimer <= 0 && !player.crouch) {
      player.attacking = true;
      player.attackType = "kick";
      player.attackTimer = 22;
      player.state = "kick";
    }
  }

  function checkHits() {
    const pAtk = getAttackBox(player);
    const eAtk = getAttackBox(enemy);

    const pHurt = getHurtBox(player);
    const eHurt = getHurtBox(enemy);

    if (pAtk && rectsOverlap(pAtk, eHurt)) {
      const dmg = player.attackType === "kick" ? 14 : 9;
      const knock = player.attackType === "kick" ? 3.8 : 2.4;
      applyDamage(player, enemy, dmg, knock);
      player.attackTimer = 0;
      player.attacking = false;
    }

    if (eAtk && rectsOverlap(eAtk, pHurt)) {
      const dmg = enemy.attackType === "kick" ? 13 : 8;
      const knock = enemy.attackType === "kick" ? 3.4 : 2.0;
      applyDamage(enemy, player, dmg, knock);
      enemy.attackTimer = 0;
      enemy.attacking = false;
    }
  }

  function updateCamera() {
    const focusX = (player.x + enemy.x) / 2;
    camX = lerp(camX, focusX - LOGICAL_W/2, 0.08);
    camX = clamp(camX, 0, world.w - LOGICAL_W);
  }

  function drawBackground() {
    // sky
    ctx.fillStyle = "#090b12";
    ctx.fillRect(0, 0, LOGICAL_W, LOGICAL_H);

    // far city
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "#0f1a2b";
    for (let i=0; i<40; i++) {
      const bx = (i * 40 - (camX * 0.2)) % 600;
      const h = 20 + (i % 5) * 10;
      ctx.fillRect(bx, 70 - h, 22, h);
    }
    ctx.globalAlpha = 1;

    // ground
    ctx.fillStyle = "#141414";
    ctx.fillRect(0, world.floorY, LOGICAL_W, LOGICAL_H - world.floorY);

    // floor lines
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = "#ffffff";
    for (let i=0; i<40; i++) {
      ctx.fillRect(((i*40 - camX) % 500), world.floorY + 12, 24, 1);
    }
    ctx.globalAlpha = 1;
  }

  function drawParticles() {
    for (let i=particles.length-1; i>=0; i--) {
      const p = particles[i];
      p.vy += 0.14;
      p.x += p.vx;
      p.y += p.vy;
      p.life--;

      ctx.globalAlpha = Math.max(0, p.life / 30);
      ctx.fillStyle = (Math.random() < 0.5) ? "#ffffff" : "#ffdd55";
      ctx.fillRect(p.x - camX, p.y, 2, 2);

      if (p.life <= 0) particles.splice(i, 1);
    }
    ctx.globalAlpha = 1;
  }

  function drawHUD() {
    hpP.style.width = (player.hp) + "%";
    hpE.style.width = (enemy.hp) + "%";
  }

  function drawFighters() {
    // Determine draw positions
    const px = player.x - camX;
    const ex = enemy.x - camX;

    // draw enemy
    drawEnemySprite(ex, enemy.y + enemy.h, 1, enemy.animT, enemy.face);

    // draw player (your pixel sprite)
    drawPlayerSprite(playerSprite, px, player.y + player.h, player.animT, player.face, player.state);

    // hitboxes debug (optional)
    // ctx.strokeStyle = "red";
    // const hb = getAttackBox(player);
    // if (hb) ctx.strokeRect(hb.x - camX, hb.y, hb.w, hb.h);
  }

  function checkWinLose() {
    if (gameOver) return;

    if (player.hp <= 0) {
      gameOver = true;
      fightStarted = false;
      showCenterText("YOU LOSE", 1400);
      setTimeout(() => location.reload(), 1600);
    }

    if (enemy.hp <= 0) {
      gameOver = true;
      fightStarted = false;
      showCenterText("YOU WIN!", 1400);

      wins++;
      localStorage.setItem("pspFighterWins", wins.toString());
      winsUI.textContent = "Wins: " + wins;

      setTimeout(() => location.reload(), 1600);
    }
  }

  function updateIntro() {
    if (introTimer > 0) {
      introTimer--;
      if (introTimer === 0) {
        fightStarted = true;
      }
    }
  }

  function update() {
    handleInput();

    if (fightStarted) {
      cpuThink(enemy, player);
    }

    updateFighter(player);
    updateFighter(enemy);

    // Face each other automatically
    if (fightStarted) {
      player.face = (enemy.x > player.x) ? 1 : -1;
      enemy.face = (player.x > enemy.x) ? 1 : -1;
    }

    if (fightStarted) {
      checkHits();
    }

    updateCamera();
    drawHUD();
    checkWinLose();
    updateIntro();
  }

  function render() {
    // screen shake
    let sx = 0, sy = 0;
    if (shake > 0) {
      sx = (Math.random() * shake - shake/2);
      sy = (Math.random() * shake - shake/2);
      shake *= 0.85;
      if (shake < 0.05) shake = 0;
    }

    ctx.save();
    ctx.translate(sx, sy);

    drawBackground();
    drawParticles();
    drawFighters();

    // floor highlight
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = "#00ccff";
    ctx.fillRect(0, world.floorY, LOGICAL_W, 2);
    ctx.globalAlpha = 1;

    // combo text
    if (player.combo >= 2 && player.comboTimer > 0) {
      ctx.fillStyle = "white";
      ctx.font = "12px monospace";
      ctx.fillText(player.combo + " HIT COMBO!", 10, 80);
    }

    ctx.restore();
  }

  function loop() {
    update();
    render();
    requestAnimationFrame(loop);
  }

  playerImg.onload = () => {
    playerSprite = makePixelSprite(playerImg, 32, 48);
    loop();
  };

  playerImg.onerror = () => {
    showCenterText("player.png bulunamadı!", 1800);
    loop();
  };

})();
</script>
</body>
</html>
